<WCF>
  <Header>
    - WCF is Microsoft's next-generation programming platform and runtime system for building, configuring and deploying network-distributed services
  </Header>
  <ABC>
    <Address Motto="Where is the service?">

    </Address>
    <Binding Motto="How do I talk to the service?">

    </Binding>
    <Contract Motto="What can the service do for me?">
      <Service-Contract>
        - WCF contracts are defined in one of two ways. You can design or otherwise acquire a WSDL contract description and turn it into an WCF contract description using the svcutil.exe tool is included with the WCF runtime binaries. "WCF contract description" means that the tool will generate code that's marked up with metadata attributes telling the WCF runtime about the specifics of the contract definition.

        - Contrary to ASMX, where the wsdl.exe tool imports WSDL descriptions into either a concrete proxy class implementation or a concrete (yet abstract) class server implementation, the WCF tool will generate a contract description as an interface declaration that can be used both for the server-side and for the proxy. So if you wanted to import a contract description for Microsoft's TerraService, the command-line would look likely like this:

        Svcutil.exe http://terraserver.microsoft.com/TerraService2.asmx /useXmlSerializer

        - The resulting output is a source-code file (you can specify the programming language using the /language switch) that contains all necessary data declarations, service interfaces and, for convenience, readily implemented proxy classes

        <example>
          using System.ServiceModel;

          [ServiceContract] => This attribute explicitly marks a CLR interface as to carry contract metadata for WCF.
          public interface ICalculate
          {
          [OperationContract] => Each method is explicitly labeled with the [OperationContract] attribute, which is the WCF equivalent to a "public" method
          public double Add( double a, double b);
          [OperationContract]
          private double Subtract( double a, double b);
          }
        </example>
        - Based on the existence and the additional, optional parameters than can be supplied to these metadata attributes, the WCF runtime can, whenever required, turn the [ServiceContract] into an equivalent WSDL portType declaration. Each [OperationContract] declaration is then mapped to an equivalent WSDL operation definition whereby the parameter lists and return values are turned into XML schema declarations reference by the WSDL types section and the respective WSDL message mappings

        -Note that one of the methods shown is declared as private in C#, but still carries the [OperationContract] attribute. Therefore, the method can only be invoked from the outside (or from within the service class itself), but not from inside the service application
      </Service-Contract>
      <Data-Contract>
        - While a service contract defines the shape and rules for interfaces (portTypes), along with their associated messages and operations, the data contract defines the shape and rules for the data that is exchanged through operation's input and output messages.

        - The data contract defined information items that you flow across service boundaries and that are handled with additional logic on the provider and consumer side

        <example>
          [DataContract]
          public class Person
          {
          [DataMember]
          public int Id;
          [DataMember]
          public string FirstName;
          [DataMember(IsOptional = true, VersionAdded = 2)]
          public string LastName;
          }
        </example>
        - Above you see a data contract for a person. The attributes stem from the System.Runtime.Serialization namespace that is the home of the new XmlFormatter infrastructure.

        -Both the DataContractAttribute and DataMemberAttribute expose a Name property that is useful for providing explicit names for complex types and properties, respectively. As with service contracts explicit naming decouples CLR naming conventions from the contract and prevents re-factoring problems
      </Data-Contract>
      <Message-Contracts>
        -Message contracts give you more control over the actual SOAP message for a service operation request or reply. When you use message contracts you supply a type decorated with the MessageContractAttribute as the only parameter to a service operation and as the return type as shown in exmaple
        <example>
          [ServiceContract(Namespace = "urn:WCFEssentials/Samples/2008/12")]
          public interface IMyMessageService
          {
          [OperationContract]
          MyMessage AddArticleLink(MyMessage requestMessage);
          [OperationContract]
          MyMessage GetArticleLinks(MyMessage requestMessage);
          }
        </example>

        - Normally you will create request and reply message contracts, paired for each operation. By applying the MessageHeaderAttribute or the MessageBodyMemberAttribute to properties of the message contract you can create message headers and body element for serialization in a request or reply.
        - Message contracts are particularly useful in the following scenarios:
        > When you want to include custom message headers in the request or reply.
        > Disable message wrapping for interoperability with platforms that do not wrap messages.
        > Supply multiple body members in the reply.

        <example>
          [MessageContract]
          public class MyMessage
          {
          private string operation;
          private double n1;
          private double n2;
          private double result;

          //Constructor - create an empty message.

          public MyMessage() {}

          //Constructor - create a message and populate its members.

          public MyMessage(double n1, double n2, string operation,
          double result)
          {
          this.n1 = n1;
          this.n2 = n2;
          this.operation = operation;
          this.result = result;
          }

          //Constructor - create a message from another message.
          public MyMessage(MyMessage message)
          {
          this.n1 = message.n1;
          this.n2 = message.n2;
          this.operation = message.operation;
          this.result = message.result;
          }

          [MessageHeader]
          public string Operation
          {
          get { return operation; }
          set { operation = value; }
          }

          [MessageBodyMember]
          public double N1
          {
          get { return n1; }
          set { n1 = value; }
          }

          [MessageBodyMember]
          public double N2
          {
          get { return n2; }
          set { n2 = value; }
          }

          [MessageBodyMember]
          public double Result
          {
          get { return result; }
          set { result = value; }
          }
          }
        </example>
        - You can also control message protection (encryption and signing) of individual header and body elements although this is not a common requirement.
      </Message-Contracts>
      <Fault-Contract>
        - The Fault Contract sample demonstrates how to communicate error information from a service to a client

        <example>
          [ServiceContract(Namespace="http://Microsoft.ServiceModel.Samples")]
          public interface ICalculator
          {
          [OperationContract]
          int Add(int n1, int n2);
          [FaultContract(typeof(MathFault))]
          int Divide(int n1, int n2);
          }
        </example>
        - The FaultContractAttribute attribute indicates that the Divide operation may return a fault of type MathFault. A fault can be of any type that can be serialized.

        <example>
          [DataContract(Namespace="http://Microsoft.ServiceModel.Samples")]
          public class MathFault
          {
          private string operation;
          private string problemType;

          [DataMember]
          public string Operation
          {
          get { return operation; }
          set { operation = value; }
          }

          [DataMember]
          public string ProblemType
          {
          get { return problemType; }
          set { problemType = value; }
          }
          }
        </example>
        - The Divide method throws a FaultException of Type TDetails exception when a divide by zero exception occurs as shown in the following sample code. This exception results in a fault being sent to the client
      </Fault-Contract>
    </Contract>
  </ABC>
  <SOAP>
    - SOAP defines a standard communication protocol (set of rules) specification for XML-based message exchange.

    - SOAP uses different transport protocols, such as HTTP and SMTP.

    - The standard protocol HTTP makes it easier for SOAP model to tunnel across firewalls and proxies without any modifications to the SOAP protocol.

    - SOAP can sometimes be slower than middleware technologies like CORBA or ICE due to its verbose XML format.
  </SOAP>
  <REST>
    - REST Describes a set of architectural principles by which data can be transmitted over a standardized interface (such as HTTP).

    - REST does not contain an additional messaging layer and focuses on design rules for creating stateless services. A client can access the resource using the unique URI and a representation of the resource is returned. With each new resource representation, the client is said to transfer state.

    - While accessing RESTful resources with HTTP protocol, the URL of the resource serves as the resource identifier and GET, PUT, DELETE, POST and HEAD are the standard HTTP operations to be performed on that resource.
  </REST>
  <WCF-Vs-WebAPI>
    WCF	: Enables building services that support multiple transport protocols (HTTP, TCP, UDP, and custom transports) and allows switching between them.
    Web API : HTTP only. First-class programming model for HTTP. More suitable for access from various browsers, mobile devices etc enabling wide reach.

    WCF	: Enables building services that support multiple encodings (Text, MTOM, and Binary) of the same message type and allows switching between them.
    Web API : Enables building Web APIs that support wide variety of media types including XML, JSON etc.

    WCF	: Supports building services with WS-* standards like Reliable Messaging, Transactions, Message Security.
    Web API: Uses basic protocol and formats such as HTTP, WebSockets, SSL, JQuery, JSON, and XML. There is no support for higher level protocols such as Reliable Messaging or Transactions.

    WCF	: Supports Request-Reply, One Way, and Duplex message exchange patterns.
    Web API: HTTP is request/response but additional patterns can be supported through SignalRand WebSockets integration.


    WCF	: WCF SOAP services can be described in WSDL allowing automated tools to generate client proxies even for services with complex schemas.
    Web API: There is a variety of ways to describe a Web API ranging from auto-generated HTML help page describing snippets to structured metadata for OData integrated APIs.


    WCF	: Ships with the .NET framework.
    Web API: Ships with .NET framework but is open-source and is also available out-of-band as independent download.

    To whom choose between WCF or WEB API

    1. Choose WCF when you want to create a service that should support special scenarios such as one way messaging, message queues, duplex communication etc.

    2. Choose WCF when you want to create a service that can use fast transport channels when available, such as TCP, Named Pipes, or maybe even UDP (in WCF 4.5), and you also want to support HTTP when all other transport channels are unavailable.

    3. Choose Web API when you want to create a resource-oriented services over HTTP that can use the full features of HTTP (like URIs, request/response headers, caching, versioning, various content formats).

    4. Choose Web API when you want to expose your service to a broad range of clients including browsers, mobiles, iphone and tablets.
  </WCF-Vs-WebAPI>
</WCF>
